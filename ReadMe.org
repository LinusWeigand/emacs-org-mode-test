#+TITLE: Using a reverse proxy with Keycloak to authenticate users
#+PROPERTY: header-args:emacs-lisp :tangle .ecams.d/init.el
#+STARTUP: inlineimages

* Preface

The reverse proxy is currently the cutting-edge technolody to authenticate users for Web-Applications and is used by all Tech giants such as Google, Amazon, Microsoft.
This documetation shows why a reverse proxy is even necessary, the architecture and how to actually implement it with Keycloak.

* Table of contents
:PROPPERTIES:
:TOC:      :include all :ignore this
:END:
:CONTENTS:
- [[#preface][Preface]]
- [[#naive-solution][Naive Solution]]
  - [[problems-with-the-naive-solution][Problems With The Naive Solution]]
  - [[#token-flow-naive-solution][Token Flow Naive Solution]]
- [[#the-soultion-easier-and-more-secure-with-the-naive-solution][The Solution: Easier And More Secure With Authentication Gateways]]
  - [[#token-flow-solution][Token Flow Solution]]
- [[#implementation][Implementation]]
  - [[#keycloak][Keycloak]]
  - [[#reverse-proxy][Reverse Proxy]]
:END: 

* Naive Solution

The naive solution is to implement the authentication in the Web-Application itself. 

This is a very bad idea, because it is very hard to implement and maintain.
The solution to this problem is an authentication server which is responsible for the authentication and the Web-Application only has to check if the user is authenticated.

#+CAPTION: The Naive Solution Flow
#+MAME: naive-solution
[[https://raw.githubusercontent.com/LinusWeigand/emacs-org-mode-test/main/.github/images/naive_solution.png]]

** Token Flow Naive Solution

The client sends a request to the Web-Application and the Web-Application checks if the client has an valid access token.
If the client has an valid access token, the Web-Application the page data is send to the browser. 
If the client has no valid access token, the Web-Application redirects the user to the authentication server.

The user has to login and the authentication server returns an access and an id token in the URL.
These are then stored in the browser and the user gets redirected to the Web-Application.

** Problems With The Naive Solution

The problem is the inherent security flaws this approach comes with, because the user can view, copy and manipulate the access and the id token.
Also if the user uses a public computer or a proxy server, the access and the id token can be stolen.

But there's another problem: browsers are not able to store the access and the id token in a secure way.
There are numerous approaches to cross-site scripting ant thus to hacking into a SPA.

* The Solution: Easier And More Secure With Authentication Gateways

As shown in the previous section, the naive solution is not secure and not easy to implement.
For this reason, an approach was developed: Server-Side OAuth 2.0 and server-side Token handling.

To avoid this server-side logic from bleeding into out server-side APIs, we could encapsulate it in an reusable reverse proxy also called Authentication Gateway:

#+CAPTION: The Reverse Proxy Flow
#+MAME: reverse-proxy
[[https://raw.githubusercontent.com/LinusWeigand/emacs-org-mode-test/main/.github/images/reverse_proxy.png]]

The idea is to tunnel are calls from the client through the gateway. This gateway takes care of obtaining and refreshing token and forwarding the tokens to the resource server (the Web API).
However all tokens remain at the gateway. The browser only gets an HTTP-only cookie that represents the session at the gateway.
Since this cookie is HTTP-only, an attacker cannot steal it via a JavaScript-based attack.

Since the tokens never end up in the browser, many of the possible attacks do not apply.
In addition, this approach drstically simplifies the implementation of the frontend, since it no longer has to deal with tokens and the user is now authenticated without any frontend code.

In order to initiate (re)authentication or to log off the user, it is sufficient to be forwarded to a URL provided by the gateway. The front end can obtain information about the current user via a simple gateway service.

** Token Flow Solution

The client sends a request to the gateway. The gateway checks if it has an valid access token belonging to the user. This is done by checking the HTTP-only cookie. 
If the gateway has an valid access token, the gateway forwards the request to the Web-Application. 
If the gateway has no valid access token, the gateway redirects the user to the authentication server.

The user has to login and the authentication server returns an access and an id token to the gateway.
These are then stored in the gateway and the user gets redirected to the Web-Application.
The Web-Application can now access the user data, reauthenticate and logout via endpoints of the authorization server.

* Implementation

To implement this architecture we first have to setup the authentication server with Keycloak and get it running.
We then have to start the Application server and configure the reverse proxy accordingly.

** Keycloak

There are two ways to setup Keycloak: either with Docker or with a standalone installation.

*** Setup and installation with Docker

To setup Keycloak with Docker, we first have to install Docker and run the following command:

#+BEGIN_SRC shell
docker run -p 8080:8080 -e KEYCLOAK_USER=admin -e KEYCLOAK_PASSWORD=admin quay.io/keycloak/keycloak:15.0.2
#+END_SRC

This will start Keycloak on port 8080 and create an admin user with the username admin and the password admin.

*** Setup and installation with a standalone installation

To setup Keycloak with a standalone installation, we first have to download the Keycloak server from the [[https://www.keycloak.org/downloads][official website]].

After we have downloaded the server, we have to unzip the file and run the following command:

#+BEGIN_SRC shell
./bin/add-user-keycloak.sh -u admin -p admin
#+END_SRC

This will create an admin user with the username admin and the password admin.

After we have created the admin user, we have to start the server with the following command:

#+BEGIN_SRC shell
./bin/standalone.bat -Djboss.socket.binding.port-offset=100
#+END_SRC

This will start the server on port 8180.
We do this because the server will be running on port 8080.

After we have started the server, we have to create a realm and a client.

To create a realm, open localhost:8180 in a browser and click on the "Administration Console" button and login with the admin user.

#+CAPTION: Keycloak Home
#+MAME: keycloak-home
[[https://raw.githubusercontent.com/LinusWeigand/emacs-org-mode-test/main/.github/images/keycloak_home.png]]

After we have logged in, we have to create a realm.
To do this, click on the "Add realm" button and enter the name of the realm, e.g. myrealm.

#+CAPTION: Keycloak Home
#+MAME: keycloak-home
[[https://raw.githubusercontent.com/LinusWeigand/emacs-org-mode-test/main/.github/images/keycloak_admin_add_realm-fix.png]]

#+CAPTION: Keycloak Home 2
#+MAME: keycloak-home2
[[https://raw.githubusercontent.com/LinusWeigand/emacs-org-mode-test/main/.github/images/keycloak_admin_add_realm2-fix.png]]

After we have created the realm, we have to create a client.
To do this, click on the "Clients" button and then on the "Create" button.

#+CAPTION: Keycloak Clients Tab
#+MAME: keycloak-clients-tab
[[https://raw.githubusercontent.com/LinusWeigand/emacs-org-mode-test/main/.github/images/keycloak_admin_clients_tab.png]]

#+CAPTION: Keycloak Create Client
#+MAME: keycloak-create-client
[[https://raw.githubusercontent.com/LinusWeigand/emacs-org-mode-test/main/.github/images/keycloak_admin_create_client.png]]

Enter "gateway" as the name of the client and click on the "Save" button.

After we have created the client, we have to configure the client.
To do this, click on the "Settings" button and enter the following values:

- Access Type: confidential
- Valid Redirect URIs: http://localhost:8080/*
- Web Origins: http://localhost:8080

#+CAPTION: Keycloak Configure Client
#+MAME: keycloak-configure-client
[[https://raw.githubusercontent.com/LinusWeigand/emacs-org-mode-test/main/.github/images/keycloak_admin_configure_client.png]]

This will configure the client to use the authorization code flow and to allow the gateway to access the client. 
The Access Type has to be confidential, because the gateway will be using the client secret to authenticate itself.
The Valid Redirect URIs and the Web Origins have to be set to the URL of the gateway, because the gateway will be redirecting the user to the authentication server.

Now we have to configure the client scopes.
To do this, click on the "Client Scopes" button and add the following scopes to default and optional:

#+CAPTION: Keycloak Client Scopes
#+MAME: keycloak-client-scopes
[[https://raw.githubusercontent.com/LinusWeigand/emacs-org-mode-test/main/.github/images/keycloak_admin_client_scopes.png]]

After we have configured the client, we have to create a user.
To do this, click on the "Users" button and then on the "Add user" button.

#+CAPTION: Keycloak Users Tab
#+MAME: keycloak-users-tab
[[https://raw.githubusercontent.com/LinusWeigand/emacs-org-mode-test/main/.github/images/keycloak_admin_users_tab.png]]

#+CAPTION: Keycloak Create User
#+MAME: keycloak-create-user
[[https://raw.githubusercontent.com/LinusWeigand/emacs-org-mode-test/main/.github/images/keycloak_admin_create_user.png]]

Enter the username, Email, first name and last name of the user and click on the "Save" button.

After we have created the user, we have to set a password for the user.
To do this, click on the "Credentials" button and enter the password of the user.
Turn on the "Temporary" switch and click on the "Set Password" button.

#+CAPTION: Keycloak Configure User
#+MAME: keycloak-configure-user
[[https://raw.githubusercontent.com/LinusWeigand/emacs-org-mode-test/main/.github/images/keycloak_admin_configure_user.png]]


Now we have to create a role for accessing the Web-Application.
To do this, click on the "Roles" button and then on the "Add Role" button.
Enter "myrole" as the name of the role and click on the "Save" button.

#+CAPTION: Keycloak Roles Tab
#+MAME: keycloak-roles-tab
[[https://raw.githubusercontent.com/LinusWeigand/emacs-org-mode-test/main/.github/images/keycloak_admin_roles_tab.png]]

#+CAPTION: Keycloak Create Role
#+MAME: keycloak-create-role
[[https://raw.githubusercontent.com/LinusWeigand/emacs-org-mode-test/main/.github/images/keycloak_admin_create_role.png]]

After we have created the role, we have to assign the role to the user.
To do this, Navigate to the user and click on the "Role Mappings" button and add the role "myrole" to the Assigned Roles.

#+CAPTION: Keycloak Configure User Roles
#+MAME: keycloak-configure-user-roles
[[https://raw.githubusercontent.com/LinusWeigand/emacs-org-mode-test/main/.github/images/keycloak_admin_configure_user_roles.png]]

** Revere Proxy

The Revere Proxy will be configured to route the requests to Keycloak and the Web-Application.

*** Setup and installation of the Revere Proxy

To setup the Revere Proxy, we have clone the repository of the Revere Proxy.
To do this, run the following commands:

#+BEGIN_SRC shell

















