#+TITLE: Using a reverse proxy with Keycloak to authenticate users
#+PROPERTY: header-args:emacs-lisp :tangle .ecams.d/init.el
#+STARTUP: inlineimages

* Preface

The reverse proxy is currently the cutting-edge technolody to authenticate users for Web-Applications and is used by all Tech giants such as Google, Amazon, Microsoft.
This documetation shows why a reverse proxy is even necessary, the architecture and how to actually implement it with Keycloak.

* Table of contents
:PROPPERTIES:
:TOC:      :include all :ignore this
:END:
:CONTENTS:
- [[#preface][Preface]]
- [[#naive-solution][Naive Solution]]
  - [[problems-with-the-naive-solution][Problems With The Naive Solution]]
  - [[#token-flow-naive-solution][Token Flow Naive Solution]]
- [[#the-soultion-easier-and-more-secure-with-the-naive-solution][The Solution: Easier And More Secure With Authentication Gateways]]
  - [[#token-flow-solution][Token Flow Solution]]
- [[#implementation][Implementation]]
  - [[#keycloak][Keycloak]]
  - [[#reverse-proxy][Reverse Proxy]]
:END: 

* Naive Solution

The naive solution is to implement the authentication in the Web-Application itself. 
The Web-Application has to implement the authentication itself.
This is a very bad idea, because it is very hard to implement and maintain.
The solution to this problem is authentication server which is responsible for the authentication and the Web-Application only has to check if the user is authenticated.

#+CAPTION: The Naive Solution Flow
#+MAME: naive-solution
[[https://raw.githubusercontent.com/LinusWeigand/emacs-org-mode-test/main/.github/images/naive_solution.png]]

** Token Flow Naive Solution

The client sends a request to the Web-Application and the Web-Application checks if the client has an valid access token.
If the client has an valid access token, the Web-Application the page data is send to the browser. 
If the client has no valid access token, the Web-Application redirects the user to the authentication server.
The user has to login and the authentication server returns an access and an id token in the URL.
These are then stored in the browser and the user gets redirected to the Web-Application.

** Problems With The Naive Solution

The problem is the inherent security flaws this approach comes with, because the user can view, copy and manipulate the access and the id token.
Also if the user uses a public computer or a proxy server, the access and the id token can be stolen.
But there's another problem: browsers are not able to store the access and the id token in a secure way.
There are numerous approaches to cross-site scripting ant thus to hacking into a SPA.

* The Solution: Easier And More Secure With Authentication Gateways

As shown in the previous section, the naive solution is not secure and not easy to implement.
For this reason, an approach was developed: Server-Side OAuth 2.0 and server-side Token handling.

To avoid this server-side logic from bleeding into out server-side APIs, we could encapsulate it in an reusable reverse proxy also called Authentication Gateway:

#+CAPTION: The Reverse Proxy Flow
#+MAME: reverse-proxy
[[https://raw.githubusercontent.com/LinusWeigand/emacs-org-mode-test/main/.github/images/reverse_proxy.png]]

The idea is to tunnel are calls from the client through the gateway. This gateway takes care of obtaining and refreshing token and forwarding the tokens to the resource server (the Web API).
However all tokens remain at the gateway. The browser only gets an HTTP-only cookie that represents the session at the gateway.
Since this cookie is HTTP-only, an attacker cannot steal it via a JavaScript-based attack.

Since the tokens never end up in the browser, many of the possible attacks do not apply.
In addition, this approach drstically simplifies the implementation of the frontend, since it no longer has to deal with tokens and the user is now authenticated without any frontend code.

In order to initiate (re)authentication or to log off the user, it is sufficient to be forwarded to a URL provided by the gateway. The front end can obtain information about the current user via a simple gateway service.

** Token Flow Solution

The client sends a request to the gateway. The gateway checks if it has an valid access token belonging to the user. This is done by checking the HTTP-only cookie. 
If the gateway has an valid access token, the gateway forwards the request to the Web-Application. 
If the gateway has no valid access token, the gateway redirects the user to the authentication server.
The user has to login and the authentication server returns an access and an id token to the gateway.
These are then stored in the gateway and the user gets redirected to the Web-Application.
The Web-Application can now access the user data, reauthenticate and logout via endpoints of the authorization server.









